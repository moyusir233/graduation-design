# 数据收集服务部署的模板
# 用于提供负责均衡服务而定义的service
apiVersion: v1
kind: Service
metadata:
  name: {{.Values.username}}-dc
  labels:
    user: {{.Values.username}}
spec:
  selector:
    app: {{.Values.username}}-dc
    user: {{.Values.username}}
  ports:
    - port: 8000
      targetPort: 8000
      name: http
    - port: 9000
      targetPort: 9000
      name: grpc
  type: ClusterIP
---
# 部署数据收集statefulSet使用的无头服务
apiVersion: v1
kind: Service
metadata:
  name: {{.Values.username}}-dc-headless
  labels:
    user: {{.Values.username}}
spec:
  selector:
    app: {{.Values.username}}-dc
    user: {{.Values.username}}
  ports:
    - port: 8000
      targetPort: 8000
      name: http
    - port: 9000
      targetPort: 9000
      name: grpc
  type: ClusterIP
  clusterIP: None
---
# 为了使提供数据收集服务的每个pod具有稳定的网络地址，这里使用statefulSet部署
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: {{.Values.username}}-dc
  labels:
    app: {{.Values.username}}-dc
    user: {{.Values.username}}
spec:
  replicas: 2
  selector:
    matchLabels:
      app: {{.Values.username}}-dc
      user: {{.Values.username}}
  serviceName: {{.Values.username}}-dc-headless
  template:
    metadata:
      labels:
        app: {{.Values.username}}-dc
        user: {{.Values.username}}
    spec:
      volumes:
        # 初始化环境使用的脚本
        - name: shell
          configMap:
            name: shell
            defaultMode: 0777
            items:
              - key: build.sh
                path: build.sh
        # 拉取gitee私有仓库使用的ssh密钥
        - name: key
          configMap:
            name: key
            defaultMode: 0600
        # 放置二进制可执行程序的中转目录
        - name: tmp
          emptyDir: {}
        # 生成的代码也以configMap的形式挂载进去，由服务中心处理注册请求后动态创建
        - name: generated-code
          configMap:
            name: {{.Values.username}}-dc-code
        # 数据收集服务运行时使用的配置文件
        - name: config
          configMap:
            name: config
            items:
              - key: dc-config.yaml
                path: config.yaml
      # TODO 在statefulSet中，利用initContainer使每个pod都拉取代码然后进行编译，造成了同样代码的重复编译，如何解决？
      initContainers:
        - name: build
          image: golang:1.17
          imagePullPolicy: IfNotPresent
          command: ["/shell/build.sh"]
          volumeMounts:
            # 执行编译使用的脚本
            - mountPath: /shell
              name: shell
            # 拉取代码使用的公钥
            - mountPath: /root/.ssh
              name: key
            # 放置编译后得到的二进制可执行程序的共享目录
            - mountPath: /app
              name: tmp
            # 由服务中心生成的代码
            - mountPath: /generated-code
              name: generated-code
          # 执行编译脚本所需要的环境变量
          env:
            # 项目代码文件的仓库地址
            - name: PROJECT_REPO_ADDRESS
              value:
            # 需要拉取的分支名字
            - name: PROJECT_BRANCH
              value:
            # 项目目录名称
            - name: PROJECT_DIR
              value:
            # 相对于项目根目录的，存放项目protobuf服务定义文件的目录的相对路径
            - name: PROJECT_API_DIR
              value:
            # 相对于项目根目录的，存放项目service层源代码的目录的相对路径
            - name: PROJECT_SERVICE_DIR
              value:
      containers:
        - name: {{.Values.username}}-dc
          image: moyusir233/graduation-design:data-collection
          imagePullPolicy: IfNotPresent
          volumeMounts:
            # 存放编译后得到的二进制可执行程序的目录
            - mountPath: /app
              name: tmp
            # 应用运行所需的配置文件目录
            - mountPath: /etc/app-configs
              name: config
          # 服务运行所需的环境变量
          env:
            # 服务对象的用户id
            - name: USERNAME
              value: {{.Values.username}}
            # pod用于向kong网关注册服务时使用的名称
            - name: SERVICE_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            # statefulSet使用的headless service的名称，用于给pod组建域名
            - name: HEADLESS_SERVICE_NAME
              value: {{.Values.username}}-dc-headless
            # 项目使用的域名，用于服务向网关注册路由时，增加Host请求头的匹配规则
            - name: APP_DOMAIN_NAME
              value:
          ports:
            - containerPort: 8000
            - containerPort: 9000
          livenessProbe:
            initialDelaySeconds: 10
            periodSeconds: 60
            tcpSocket:
              port: 8000
          readinessProbe:
            initialDelaySeconds: 10
            periodSeconds: 60
            tcpSocket:
              port: 8000
      restartPolicy: Always