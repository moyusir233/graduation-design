{{/* 预定义的，配置管理相关服务函数的子模板，包括grpc的服务函数和go service层的函数 */}}

{{/* go函数部分 */}}

{{/* 定义创建上传设备初始配置信息流函数的模板，只需要注入DeviceClassID
// CreateInitialConfigSaveStream 用于客户端上传设备初始配置信息
// 在保存设备初始配置时，当客户端请求头中包含clientID时，
// 程序会为该clientID与传送过来的配置信息对应的设备建立路由资源，
// 然后客户端可以使用该clientID建立的配置更新流，接收相应的配置更新信息
*/}}
{{define "CreateInitialConfigSaveStream" -}}
func (s *ConfigService) CreateInitialConfigSaveStream{{.}}(conn pb.Config_CreateInitialConfigSaveStream{{.}}Server) error {
	// 设备类别号，代码生成时注入
	var (
		clientID      string
		deviceClassID = {{.}}
	)

	// 检查请求头中是否包含clientID
	md, ok := metadata.FromIncomingContext(conn.Context())
	if value := md.Get(CLIENT_ID_HEADER); ok && len(value) != 0 {
		clientID = value[0]
		s.logger.Infof("与 %v 建立了传输设备初始配置的grpc流", clientID)
	} else {
		s.logger.Info("与未知用户建立了传输设备初始配置的grpc流")
	}

	for {
		var(
			config *pb.DeviceConfig{{.}}
			err error
		)
		recvCtx,cancel:=context.WithCancel(context.Background())
		go func() {
			defer cancel()
			config, err = conn.Recv()
		}()

		select {
		case <-conn.Context().Done():
			s.logger.Infof("检测到了闲置或超时的连接,关闭了 %v 的传输设备初始配置的grpc流", clientID)
			return nil
		case <-recvCtx.Done():
			if err == io.EOF {
				s.logger.Infof("关闭了 %v 的传输设备初始配置的grpc流", clientID)
				return conn.SendAndClose(&pb.ConfigServiceReply{Success: true})
			} else if err != nil {
				return errors.Newf(
					500, "Service_Config_Error",
					"接收用户 %v 的初始设备配置信息时发生了错误:%v", clientID, err)
			}

			// 提取设备基本信息进行保存或路由的激活
			info := &biz.DeviceGeneralInfo{DeviceClassID: deviceClassID}
			info.DeviceID = config.Id

			// 若clientID不为空，则建立关于该clientID的路由信息
			// TODO 考虑错误处理
			if clientID != "" {
				err = s.updater.ConnectDeviceAndClientID(clientID, info)
				if err != nil {
					return err
				}
			}

			// TODO 设备初始配置保存出错时如何处理，使用怎样的错误模型返回？
			if err = s.uc.SaveDeviceConfig(info, config); err != nil {
				return err
			}
		}
	}
}
{{- end}}

{{/* 定义创建设备配置更新流函数的模板，只需要注入DeviceClassID
// CreateConfigUpdateStream 用于客户端建立配置更新的推送流
// 在客户端建立设备配置更新流时，服务器都会分配给客户端一个唯一的clientID，
// 之后，所有利用该ID进行初始配置保存以及状态信息传输的设备的配置更新信息，都会推送到该ID对应的配置更新流中
// 即哪台设备的配置更新信息推送到该配置更新流，是由利用该ID传输的初始配置信息以及设备状态信息决定的
*/}}
{{define "CreateConfigUpdateStream" -}}
func (s *ConfigService) CreateConfigUpdateStream{{.}}(conn pb.Config_CreateConfigUpdateStream{{.}}Server) error {
	var (
		clientID      string
		deviceClassID = {{.}}
		info          = &biz.DeviceGeneralInfo{DeviceClassID: deviceClassID}
	)

	// 首先从客户端流请求头中提取clientID，允许客户端复用clientID,
	md, ok := metadata.FromIncomingContext(conn.Context())
	if value := md.Get(CLIENT_ID_HEADER); ok && len(value) != 0 {
		clientID = value[0]
	} else {
		// 若请求头中不存在，则申请创建新的clientID，通过响应头并发送给客户端
		id, err := s.updater.CreateClientID()
		if err != nil {
			return err
		} else {
			clientID = id
		}

		// 将clientID存放到响应头中发送
		md = metadata.New(map[string]string{CLIENT_ID_HEADER: clientID})
		err = conn.SendHeader(md)
		// TODO 考虑错误处理
		if err != nil {
			return errors.Newf(
				500, "Service_Config_Error", "发送grpc请求头时发生了错误:%v", err)
		}
	}

	s.logger.Infof("与 %v 建立了传输配置更新信息的grpc流", clientID)

	// 获得clientID对应的updateChannel
	ctx, cancel := context.WithCancel(conn.Context())
	updateChannel, err := s.updater.GetDeviceUpdateMsgChannel(ctx, clientID, new(pb.DeviceConfig{{.}}))
	if err != nil {
		return err
	}
	defer cancel()

	// 不断从相应的channel中获得配置更新信息，并发送给客户端
	for c := range updateChannel {
		config := c.(*pb.DeviceConfig{{.}})
		err := conn.Send(config)
		if err != nil {
			return errors.Newf(
				500, "Service_Config_Error",
				"向用户 %v 发送配置更新消息时发生了错误:%v", clientID, err)
		}

		reply, err := conn.Recv()
		if err == io.EOF {
			s.logger.Infof("关闭了 %v 的传输配置更新信息的grpc流", clientID)
			return nil
		}
		if err != nil {
			return errors.Newf(
				500, "Service_Config_Error",
				"接收用户 %v 传输的配置更新消息响应时发生了错误:%v", clientID, err)
		}
		// 当客户端给出发送不成功的答复时，尝试重发一次
		// TODO 考虑配置最大重发次数?
		if !reply.Success {
			conn.Send(config)
		} else {
			// TODO 考虑设备配置保存失败时如何处理
			info.DeviceID = config.Id
			err := s.uc.SaveDeviceConfig(info, config)
			if err != nil {
				return err
			}
		}
		// 客户端表示需要断开连接
		if reply.End {
			s.logger.Infof("关闭了 %v 的传输配置更新信息的grpc流", clientID)
			break
		}
	}
	return nil
}
{{- end}}

{{/* 定义更新设备配置函数的模板，需要注入DeviceClassID
// UpdateDeviceConfig 接收到设备配置更新的http请求时，依据设备信息得到相应的channel，并进行更新消息的推送
*/}}
{{define "UpdateDeviceConfig" -}}
func (s *ConfigService) UpdateDeviceConfig{{.}}(ctx context.Context, req *pb.DeviceConfig{{.}}) (*pb.ConfigServiceReply, error) {
	// 设备类别号，代码生成时注入
	deviceClassID := {{.}}
	info := &biz.DeviceGeneralInfo{DeviceClassID: deviceClassID, DeviceID: req.Id}
	// 查询节点，将配置更新信息发送到相应channel中
	err := s.updater.UpdateDeviceConfig(info, req)
	if err != nil {
		return nil, errors.Newf(500,
			"Service_Config_Error",
			"更新设备配置时发生了未知错误:%v", err,
		)
	}

	return &pb.ConfigServiceReply{Success: true}, nil
}
{{- end}}

{{/* grpc服务部分 */}}

{{/* 更新设备配置的服务定义模板，需要注入DeviceClassID
// 更新指定设备的配置
*/}}
{{define "UpdateDeviceConfigProto" -}}
rpc UpdateDeviceConfig{{.}}(DeviceConfig{{.}}) returns (ConfigServiceReply) {
	option (google.api.http) = {
		post: "/configs/{{.}}"
		body: "*"
	};
};
{{- end}}

{{/* 创建设备配置更新流的服务定义的模板，需要注入DeviceClassID
// 用于和底层设备客户端建立用于配置更新的grpc数据流
*/}}
{{define "CreateConfigUpdateStreamProto" -}}
rpc CreateConfigUpdateStream{{.}}(stream ConfigUpdateReply) returns (stream DeviceConfig{{.}});
{{- end}}

{{/* 创建初始配置上传流的服务定义的模板，需要注入DeviceClassID
// 从底层数据客户端收集设备初始配置
*/}}
{{define "CreateInitialConfigSaveStreamProto" -}}
rpc CreateInitialConfigSaveStream{{.}}(stream DeviceConfig{{.}}) returns (ConfigServiceReply);
{{- end}}